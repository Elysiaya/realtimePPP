package org.example.gnss.ppp

import org.example.gnss.toRadians
import kotlin.math.*

/**
 * Global Mapping Function (GMF)
 * @param doy 年积日
 * @param latitude 纬度，角度制
 * @param longitude 经度，角度制
 * @param height 高度（m）
 * @param elevation 高度角，单位角度
 * @return
 */
fun globalMappingFunction(doy: Int, latitude: Double, longitude: Double, height: Double, elevation: Double): Pair<Double, Double> {

    val zd = (90-elevation).toRadians()



    // Coefficients
    val ah_mean = doubleArrayOf(
        1.2517e2, 8.503e-1, 6.936e-2, -6.760e0, 1.771e-1,
        1.130e-2, 5.963e-1, 1.808e-2, 2.801e-3, -1.414e-3,
        -1.212e0, 9.300e-2, 3.683e-3, 1.095e-3, 4.671e-5,
        3.959e-1, -3.867e-2, 5.413e-3, -5.289e-4, 3.229e-4,
        2.067e-5, 3.000e-1, 2.031e-2, 5.900e-3, 4.573e-4,
        -7.619e-5, 2.327e-6, 3.845e-6, 1.182e-1, 1.158e-2,
        5.445e-3, 6.219e-5, 4.204e-6, -2.093e-6, 1.540e-7,
        -4.280e-8, -4.751e-1, -3.490e-2, 1.758e-3, 4.019e-4,
        -2.799e-6, -1.287e-6, 5.468e-7, 7.580e-8, -6.300e-9,
        -1.160e-1, 8.301e-3, 8.771e-4, 9.955e-5, -1.718e-6,
        -2.012e-6, 1.170e-8, 1.790e-8, -1.300e-9, 1.000e-10
    )

    val bh_mean = doubleArrayOf(
        0.000e0, 0.000e0, 3.249e-2, 0.000e0, 3.324e-2,
        1.850e-2, 0.000e0, -1.115e-1, 2.519e-2, 4.923e-3,
        0.000e0, 2.737e-2, 1.595e-2, -7.332e-4, 1.933e-4,
        0.000e0, -4.796e-2, 6.381e-3, -1.599e-4, -3.685e-4,
        1.815e-5, 0.000e0, 7.033e-2, 2.426e-3, -1.111e-3,
        -1.357e-4, -7.828e-6, 2.547e-6, 0.000e0, 5.779e-3,
        3.133e-3, -5.312e-4, -2.028e-5, 2.323e-7, -9.100e-8,
        -1.650e-8, 0.000e0, 3.688e-2, -8.638e-4, -8.514e-5,
        -2.828e-5, 5.403e-7, 4.390e-7, 1.350e-8, 1.800e-9,
        0.000e0, -2.736e-2, -2.977e-4, 8.113e-5, 2.329e-7,
        8.451e-7, 4.490e-8, -8.100e-9, -1.500e-9, 2.000e-10
    )
    val ah_amp = doubleArrayOf(
        -2.738e-01, -2.837e+00, +1.298e-02, -3.588e-01, +2.413e-02,
        +3.427e-02, -7.624e-01, +7.272e-02, +2.160e-02, -3.385e-03,
        +4.424e-01, +3.722e-02, +2.195e-02, -1.503e-03, +2.426e-04,
        +3.013e-01, +5.762e-02, +1.019e-02, -4.476e-04, +6.790e-05,
        +3.227e-05, +3.123e-01, -3.535e-02, +4.840e-03, +3.025e-06,
        -4.363e-05, +2.854e-07, -1.286e-06, -6.725e-01, -3.730e-02,
        +8.964e-04, +1.399e-04, -3.990e-06, +7.431e-06, -2.796e-07,
        -1.601e-07, +4.068e-02, -1.352e-02, +7.282e-04, +9.594e-05,
        +2.070e-06, -9.620e-08, -2.742e-07, -6.370e-08, -6.300e-09,
        +8.625e-02, -5.971e-03, +4.705e-04, +2.335e-05, +4.226e-06,
        +2.475e-07, -8.850e-08, -3.600e-08, -2.900e-09, +0.000e+00
    )

    val bh_amp = doubleArrayOf(
        +0.000e+00, +0.000e+00, -1.136e-01, +0.000e+00, -1.868e-01,
        -1.399e-02, +0.000e+00, -1.043e-01, +1.175e-02, -2.240e-03,
        +0.000e+00, -3.222e-02, +1.333e-02, -2.647e-03, -2.316e-05,
        +0.000e+00, +5.339e-02, +1.107e-02, -3.116e-03, -1.079e-04,
        -1.299e-05, +0.000e+00, +4.861e-03, +8.891e-03, -6.448e-04,
        -1.279e-05, +6.358e-06, -1.417e-07, +0.000e+00, +3.041e-02,
        +1.150e-03, -8.743e-04, -2.781e-05, +6.367e-07, -1.140e-08,
        -4.200e-08, +0.000e+00, -2.982e-02, -3.000e-03, +1.394e-05,
        -3.290e-05, -1.705e-07, +7.440e-08, +2.720e-08, -6.600e-09,
        +0.000e+00, +1.236e-02, -9.981e-04, -3.792e-05, -1.355e-05,
        +1.162e-06, -1.789e-07, +1.470e-08, -2.400e-09, -4.000e-10
    )

    val aw_mean = doubleArrayOf(
        +5.640e+01, +1.555e+00, -1.011e+00, -3.975e+00, +3.171e-02,
        +1.065e-01, +6.175e-01, +1.376e-01, +4.229e-02, +3.028e-03,
        +1.688e+00, -1.692e-01, +5.478e-02, +2.473e-02, +6.059e-04,
        +2.278e+00, +6.614e-03, -3.505e-04, -6.697e-03, +8.402e-04,
        +7.033e-04, -3.236e+00, +2.184e-01, -4.611e-02, -1.613e-02,
        -1.604e-03, +5.420e-05, +7.922e-05, -2.711e-01, -4.406e-01,
        -3.376e-02, -2.801e-03, -4.090e-04, -2.056e-05, +6.894e-06,
        +2.317e-06, +1.941e+00, -2.562e-01, +1.598e-02, +5.449e-03,
        +3.544e-04, +1.148e-05, +7.503e-06, -5.667e-07, -3.660e-08,
        +8.683e-01, -5.931e-02, -1.864e-03, -1.277e-04, +2.029e-04,
        +1.269e-05, +1.629e-06, +9.660e-08, -1.015e-07, -5.000e-10
    )

    val bw_mean = doubleArrayOf(
        +0.000e+00, +0.000e+00, +2.592e-01, +0.000e+00, +2.974e-02,
        -5.471e-01, +0.000e+00, -5.926e-01, -1.030e-01, -1.567e-02,
        +0.000e+00, +1.710e-01, +9.025e-02, +2.689e-02, +2.243e-03,
        +0.000e+00, +3.439e-01, +2.402e-02, +5.410e-03, +1.601e-03,
        +9.669e-05, +0.000e+00, +9.502e-02, -3.063e-02, -1.055e-03,
        -1.067e-04, -1.130e-04, +2.124e-05, +0.000e+00, -3.129e-01,
        +8.463e-03, +2.253e-04, +7.413e-05, -9.376e-05, -1.606e-06,
        +2.060e-06, +0.000e+00, +2.739e-01, +1.167e-03, -2.246e-05,
        -1.287e-04, -2.438e-05, -7.561e-07, +1.158e-06, +4.950e-08,
        +0.000e+00, -1.344e-01, +5.342e-03, +3.775e-04, -6.756e-05,
        -1.686e-06, -1.184e-06, +2.768e-07, +2.730e-08, +5.700e-09
    )

    val aw_amp = doubleArrayOf(
        +1.023e-01, -2.695e+00, +3.417e-01, -1.405e-01, +3.175e-01,
        +2.116e-01, +3.536e+00, -1.505e-01, -1.660e-02, +2.967e-02,
        +3.819e-01, -1.695e-01, -7.444e-02, +7.409e-03, -6.262e-03,
        -1.836e+00, -1.759e-02, -6.256e-02, -2.371e-03, +7.947e-04,
        +1.501e-04, -8.603e-01, -1.360e-01, -3.629e-02, -3.706e-03,
        -2.976e-04, +1.857e-05, +3.021e-05, +2.248e+00, -1.178e-01,
        +1.255e-02, +1.134e-03, -2.161e-04, -5.817e-06, +8.836e-07,
        -1.769e-07, +7.313e-01, -1.188e-01, +1.145e-02, +1.011e-03,
        +1.083e-04, +2.570e-06, -2.140e-06, -5.710e-08, +2.000e-08,
        -1.632e+00, -6.948e-03, -3.893e-03, +8.592e-04, +7.577e-05,
        +4.539e-06, -3.852e-07, -2.213e-07, -1.370e-08, +5.800e-09
    )
    val bw_amp = doubleArrayOf(
        +0.000e+00, +0.000e+00, -8.865e-02, +0.000e+00, -4.309e-01,
        +6.340e-02, +0.000e+00, +1.162e-01, +6.176e-02, -4.234e-03,
        +0.000e+00, +2.530e-01, +4.017e-02, -6.204e-03, +4.977e-03,
        +0.000e+00, -1.737e-01, -5.638e-03, +1.488e-04, +4.857e-04,
        -1.809e-04, +0.000e+00, -1.514e-01, -1.685e-02, +5.333e-03,
        -7.611e-05, +2.394e-05, +8.195e-06, +0.000e+00, +9.326e-02,
        -1.275e-02, -3.071e-04, +5.374e-05, -3.391e-05, -7.436e-06,
        +6.747e-07, +0.000e+00, -8.637e-02, -3.807e-03, -6.833e-04,
        -3.861e-05, -2.268e-05, +1.454e-06, +3.860e-07, -1.068e-07,
        +0.000e+00, -2.658e-02, -1.947e-03, +7.131e-04, -3.506e-05,
        +1.885e-07, +5.792e-07, +3.990e-08, +2.000e-08, -5.700e-09
    )

    // Constants
    val pi = 3.14159265359
    val nmax = 9
    val mmax = 9

    // Calculate day of year
//    val doy = dmjd - 44239.0 + 1.0 - 28.0

    // Unit vector
    val x = cos(latitude) * cos(longitude)
    val y = cos(latitude) * sin(longitude)
    val z = sin(latitude)

    // Legendre polynomials
    val V = Array(nmax + 2) { DoubleArray(mmax + 2) }
    val W = Array(nmax + 2) { DoubleArray(mmax + 2) }

    V[1][1] = 1.0
    W[1][1] = 0.0
    V[2][1] = z * V[1][1]
    W[2][1] = 0.0

    for (n in 2..nmax) {
        V[n + 1][1] = ((2 * n - 1) * z * V[n][1] - (n - 1) * V[n - 1][1]) / n
        W[n + 1][1] = 0.0
    }

    for (m in 1..mmax) {
        V[m + 1][m + 1] = (2 * m - 1) * (x * V[m][m] - y * W[m][m])
        W[m + 1][m + 1] = (2 * m - 1) * (x * W[m][m] + y * V[m][m])

        if (m < nmax) {
            V[m + 2][m + 1] = (2 * m + 1) * z * V[m + 1][m + 1]
            W[m + 2][m + 1] = (2 * m + 1) * z * W[m + 1][m + 1]
        }

        for (n in (m + 2)..nmax) {
            V[n + 1][m + 1] = ((2 * n - 1) * z * V[n][m + 1] - (n + m - 1) * V[n - 1][m + 1]) / (n - m)
            W[n + 1][m + 1] = ((2 * n - 1) * z * W[n][m + 1] - (n + m - 1) * W[n - 1][m + 1]) / (n - m)
        }
    }

    // (1) Hydrostatic mapping function
    val bh = 0.0029
    val c0h = 0.062
    val (phh, c11h, c10h) = if (latitude < 0) { // Southern hemisphere
        Triple(pi, 0.007, 0.002)
    } else { // Northern hemisphere
        Triple(0.0, 0.005, 0.001)
    }

    val ch = c0h + ((cos(doy / 365.25 * 2 * pi + phh) + 1) * c11h / 2 + c10h) * (1 - cos(latitude))

    var ahm = 0.0
    var aha = 0.0
    var i = 0

    for (n in 0..nmax) {
        for (m in 0..n) {
            ahm += ah_mean[i] * V[n + 1][m + 1] + bh_mean[i] * W[n + 1][m + 1]
            aha += ah_amp[i] * V[n + 1][m + 1] + bh_amp[i] * W[n + 1][m + 1]
            i++
        }
    }

    val ah = (ahm + aha * cos(doy / 365.25 * 2 * pi)) * 1e-5

    val sine = sin(pi / 2 - zd)
    val cose = cos(pi / 2 - zd)
    var beta = bh / (sine + ch)
    var gamma = ah / (sine + beta)
    val topcon = (1 + ah / (1 + bh / (1 + ch)))
    var gmfh = topcon / (sine + gamma)

    // Height correction
    val a_ht = 2.53e-5
    val b_ht = 5.49e-3
    val c_ht = 1.14e-3
    val hs_km = height / 1000.0

    beta = b_ht / (sine + c_ht)
    gamma = a_ht / (sine + beta)
    val htTopcon = (1 + a_ht / (1 + b_ht / (1 + c_ht)))
    val htCorrCoef = 1 / sine - htTopcon / (sine + gamma)
    val htCorr = htCorrCoef * hs_km
    gmfh += htCorr

    // (2) Wet mapping function
    val bw = 0.00146
    val cw = 0.04391

    var awm = 0.0
    var awa = 0.0
    i = 0

    for (n in 0..nmax) {
        for (m in 0..n) {
            awm += aw_mean[i] * V[n + 1][m + 1] + bw_mean[i] * W[n + 1][m + 1]
            awa += aw_amp[i] * V[n + 1][m + 1] + bw_amp[i] * W[n + 1][m + 1]
            i++
        }
    }

    val aw = (awm + awa * cos(doy / 365.25 * 2 * pi)) * 1e-5

    beta = bw / (sine + cw)
    gamma = aw / (sine + beta)
    val wetTopcon = (1 + aw / (1 + bw / (1 + cw)))
    val gmfw = wetTopcon / (sine + gamma)

    return Pair(gmfh, gmfw)
}

///**
// * 计算对流层斜路径延迟
// * @param ztd 天顶对流层延迟（米）
// * @param elevation 仰角（度）
// * @param latitude 纬度（度）
// * @param height 高度（米）
// * @param doy 年积日
// * @return 斜路径延迟（米）
// */
//fun calculateTropoDelay(
//    ztd: Double,
//    elevation: Double,
//    latitude: Double,
//    height: Double,
//    doy: Int
//): Double {
//    val elevRad = Math.toRadians(elevation)
//    val latRad = Math.toRadians(latitude)
//    val (mh, mw) = calculateGmfMappingFunction(elevRad, latRad, height, doy)
//
//    // 假设干湿延迟比例（实际需根据气象数据或模型估算）
//    val zhd = ztd * 0.9  // 天顶干延迟
//    val zwd = ztd * 0.1   // 天顶湿延迟
//
//    return zhd * mh + zwd * mw
//}
